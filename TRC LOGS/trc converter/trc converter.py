#!/usr/bin/env python3
"""
trc_converter.py

Converts PCAN-View .trc (v2-like or mixed) into exact legacy v1.1 layout:
- preserves $STARTTIME and Start time: text
- removes Type token (e.g. "DT")
- normalizes each message line to fixed-column spacing exactly like the desired output
- skips conversion if file already appears to be in desired legacy format
- GUI: simple Tk file picker
"""

import re
import tkinter as tk
from tkinter import filedialog, messagebox
import os

# Pattern for v2-like lines: <num> <time> <type> <ID> <Rx/Tx> <dlc> <data...>
P_V2 = re.compile(r"^\s*(\d+)\s+([\d\.]+)\s+[A-Za-z]+\s+([0-9A-Fa-f]{1,8})\s+(Rx|Tx|RX|TX)\s+(\d+)\s*(.*)$")
# Pattern for legacy-like lines: <num>) <time> <Rx/Tx> <ID> <dlc> <data...>
P_LEG = re.compile(r"^\s*(\d+)\)?\s+([\d\.]+)\s+(Rx|Tx|RX|TX)\s+([0-9A-Fa-f]{1,8})\s+(\d+)\s*(.*)$")


def is_already_desired(lines):
    """Check if the file is already in v1.1 layout."""
    if any(";$FILEVERSION=1.1" in ln for ln in lines) and any("Message Number" in ln for ln in lines):
        return True
    return False


def extract_metadata(lines):
    fileversion = None
    starttime = None
    start_datetime = None
    for ln in lines:
        if ln.startswith(";$FILEVERSION"):
            try:
                fileversion = ln.strip().split("=", 1)[1]
            except Exception:
                fileversion = ln.strip()
        elif ln.startswith(";$STARTTIME"):
            try:
                starttime = ln.strip().split("=", 1)[1]
            except Exception:
                starttime = ln.strip()
        elif "Start time:" in ln:
            start_datetime = ln.split("Start time:", 1)[1].strip()
        if fileversion and starttime and start_datetime:
            break
    return fileversion, starttime, start_datetime


def normalize_direction(token):
    tok = token.lower()
    if tok == "rx":
        return "Rx"
    if tok == "tx":
        return "Tx"
    return token


def build_header(starttime, start_datetime):
    hdr = [
        ";$FILEVERSION=1.1",
        f";$STARTTIME={starttime if starttime else ''}",
        ";",
        f";   Start time: {start_datetime if start_datetime else ''}",
        ";   Generated by PCAN-View v5.0.1.822",
        ";",
        ";   Message Number",
        ";   |         Time Offset (ms)",
        ";   |         |        Type",
        ";   |         |        |        ID (hex)",
        ";   |         |        |        |     Data Length",
        ";   |         |        |        |     |   Data Bytes (hex) ...",
        ";   |         |        |        |     |   |",
        ";---+--   ----+----  --+--  ----+---  +  -+ -- -- -- -- -- -- --",
    ]
    return hdr


def format_line(count, time_off_str, direction, msg_id, dlc, data, num_width):
    """
    Dynamic and perfectly aligned formatter:
    - message number: right-aligned to num_width
    - always 2 spaces after ')'
    - time offset: right-aligned width 12
    - direction: 2 chars
    - consistent spacing before ID, DLC, and data bytes
    """
    id_str = str(msg_id).upper()
    dir_str = normalize_direction(direction)
    data_norm = " ".join(data.strip().split()) if data else ""

    formatted = (
        f"{count:>{num_width}})"      # message number + ')'
        f"  "                         # two spaces
        f"{float(time_off_str):>10.3f}"  # time offset, width 10.3f
        f"  "                         # two spaces
        f"{dir_str:<2}"               # Rx / Tx
        f"{'':7}"                     # 7 spaces gap
        f"{id_str:>4}"                # ID aligned
        f"  {dlc:>1}  "               # DLC with double space padding
        f"{data_norm}"
    )
    return formatted


def convert_trc(input_path):
    try:
        with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
            lines = f.readlines()
    except Exception as e:
        messagebox.showerror("TRC Converter", f"Failed to read file:\n{e}")
        return

    if is_already_desired(lines):
        messagebox.showinfo("TRC Converter", "File already in desired v1.1 layout â€” skipped.")
        return

    fileversion, starttime, start_datetime = extract_metadata(lines)
    header = build_header(starttime, start_datetime)
    output = list(header)

    parsed_lines = []
    for ln in lines:
        ln_stripped = ln.rstrip("\n")
        m2 = P_V2.match(ln_stripped)
        if m2:
            num, time_off, msg_id, direction, dlc, data = m2.groups()
            parsed_lines.append((num, time_off, direction, msg_id, dlc, data))
            continue
        mL = P_LEG.match(ln_stripped)
        if mL:
            num, time_off, direction, msg_id, dlc, data = mL.groups()
            parsed_lines.append((num, time_off, direction, msg_id, dlc, data))

    if not parsed_lines:
        messagebox.showwarning("TRC Converter", "No valid message lines found.")
        return

    # Determine width based on highest message number
    num_width = max(6, len(str(len(parsed_lines))) + 1)

    for i, (num, time_off, direction, msg_id, dlc, data) in enumerate(parsed_lines, start=1):
        out = format_line(i, time_off, direction, msg_id, dlc, data, num_width)
        output.append(out)

    out_path = (
        input_path[:-4] + "_converted.trc"
        if input_path.lower().endswith(".trc")
        else input_path + "_converted.trc"
    )

    try:
        with open(out_path, "w", encoding="utf-8") as f:
            for line in output:
                f.write(line.rstrip() + "\n")
    except Exception as e:
        messagebox.showerror("TRC Converter", f"Failed to write output:\n{e}")
        return

    messagebox.showinfo("TRC Converter", f"Conversion complete.\nSaved to:\n{out_path}")


def main():
    root = tk.Tk()
    root.withdraw()
    file_path = filedialog.askopenfilename(
        title="Select TRC file",
        filetypes=[("TRC files", "*.trc"), ("All files", "*.*")],
    )
    if not file_path:
        return
    convert_trc(file_path)


if __name__ == "__main__":
    main()
